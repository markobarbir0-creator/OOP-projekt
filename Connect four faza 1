#include <SFML/Graphics.hpp>
#include <vector>
#include <iostream>
#include <cstdlib>
using namespace std;
using namespace sf;
const float CELL_WIDTH = 800.0f / 7;
const float CELL_HEIGHT = 700.0f / 6;
class Board {
private:
    vector<vector<int>> grid;
    RectangleShape Boardshape;
public:
    const int rows = 6;
    const int columns = 7;
    Board() {
        grid.resize(rows, vector<int> (columns,0));
        Boardshape.setSize(Vector2f(800.f, 700.f));
        Boardshape.setFillColor(Color::Blue);
    }
    void draw(RenderWindow& window) {
        window.draw(Boardshape);
        for (auto i = 0; i < rows; i++) {
            for (auto j = 0; j < columns; j++) {
                CircleShape krug(45.f);
                float X = j * CELL_WIDTH + 10.f;
                float Y = i * CELL_HEIGHT + 10.f;
                krug.setPosition(X, Y);
                if (grid[i][j] == 0) {
                    krug.setFillColor(Color::White);
                    window.draw(krug);
                }
                else if (grid[i][j] == 1) {
                    krug.setFillColor(Color::Yellow);
                    window.draw(krug);
                }
                else if (grid[i][j] == 2) {
                    krug.setFillColor(Color::Red);
                    window.draw(krug);
                }
                
            }
        }
        
    }
    bool jelipun(int stupac) {
        return grid[0][stupac] != 0;
    }
    bool dodajzeton(int stupac, int igrac,int &red) {
        
        if (stupac < 0 || stupac >= columns) {
            return false;
        }
        for (int i = rows - 1; i >= 0; i--) {
            if (grid[i][stupac] == 0) {
                grid[i][stupac] = igrac;
                red = i;
                return true;
            }
        }
        return false;
    }
    bool provjerapobjede(int igrac,int stupac,int red) {
        int brojac = 0;
        for (int i = rows - 1; i >= 0; i--) { 
            if (grid[i][stupac] == igrac) {
                brojac++;
                if (brojac == 4) {
                    return true;
                }
            }
            else {
                brojac = 0;
            }    
        }
        for (int j = 0; j <columns; j++) {
            if (grid[red][j] == igrac) {
                brojac++;
                if (brojac == 4) {
                    return true;
                }
            }
            else {
                brojac = 0;
            }
        }
        for (int i = 0; i <= rows - 4; i++) {
            for (int j = 0; j <= columns - 4; j++) {
                int brojacgd = 0;
                for (int k = 0; k < 4; k++) {
                    if (grid[i + k][j + k] == igrac) brojacgd++;
                    else break;
                }
                if (brojacgd == 4) return true;
            }
        }

        return false;
    }

};
class Game{
private:
    Board board;
    int currentplayer;

public:
    Game(){
        currentplayer = rand() % 2 + 1;
    }
    int getcurrentplayer() {
        return currentplayer;
    }
    Board& getboard() {
        return board;
    }
    
    void handleclick(int x) {
        int stupac = x / CELL_WIDTH;
        int red;
        if ((stupac >= 0) && (stupac < 7)) {
            if (!board.jelipun(stupac)) {
                board.dodajzeton(stupac, currentplayer,red);
                if (board.provjerapobjede(currentplayer, stupac,red)) {
                    cout << "Igrac " << currentplayer << " je pobjedio" << endl;
                }
                currentplayer = (currentplayer == 1 ? 2 : 1);
            }
        }
    }

};

int main() {
    RenderWindow window(VideoMode(800, 700), "Connect Four - Faza 1");
    window.setFramerateLimit(60);


    Board board;
    Game game;
    
    

    while (window.isOpen()) {
        Event event;
        while (window.pollEvent(event)) {
            if (event.type == Event::Closed)
                window.close();
            if (event.type == Event::MouseButtonPressed)
                game.handleclick(event.mouseButton.x);
        }

        window.clear(Color::White);
        game.getboard().draw(window);
        window.display();

    }
    
   

    return 0;
}
